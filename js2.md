## JS高级
### 数据类型
1. 判断
* === 判断null undefined
* typeof 判断String Number Boolean
	* 不能判断object与array null和object
* instanceof 判断Object的实例
	* Function，Array都是特别对象
2. null和undefined的区别
* 定义了未赋值：undefined
* 定义赋值为null：null

3. 什么时候需要赋值为null
* 想要创造一个对象，先赋值null占住
* 在最后赋值null，释放对象

4. 严格区分数据类型和变量类型
* 数据类型：基本类型，对象类型
* 变量的类型：基本类型，引用类型 

### 数据-变量-内存 
* 栈：全局对象、局部变量
* 堆：对象

* var a = xxx,a内存中保存的是什么？
	* xxx是基本数据，保存数据
	* xxx是对象，保存对象的地址值
	* xxx是变量。保存的是xxx的内存内容

* 调用函数时，值传递还是参数传递
	* 理解1：都是值传递
	* 理解2：可能值传递，也可能是引用传递（地址值）

***

### 对象
1. 什么是对象？
	* 多个数据的封装体
	* 用来保存多个数据的容器
2. 什么时候必须使用['属性名']的方式?
	* 1.属性名包含特殊字符： - 空格
		* p['content-type']=’abc‘
	* 2. 变量名不确定
		* var propName = 'myAge'
		* p[propName] = value
***

### 函数
* 让一个函数成为任何一个对象的函数来调用

```
		var obj = {};

        function test(){
            this.name = "zj";
        }
        test.call(obj);
        console.log(obj.name);
```
#### 回调函数
1. 什么是回调函数
	* 自己定义，不是自己调用，但执行

2. 常见的回调函数
	* dom事件回调函数
	* 定时器回调
	* ajax请求回调（没学）
	* 生命周期回调函数（没学）

#### IIFE
* Immediately-Invoked Function Expression 立即执行函数表达式
```
	(function(){})() //匿名函数自调用
```
* 作用：
	* 隐藏实现
	*  不会污染外部空间（全局）命名空间

#### this
1. this是什么？
	* 任何函数本质上都是通过某个对象调用的，如果没有指定就是window
	* 所有函数内部都有一个变量this
	* 值是调用函数的当前对象



* * *
#### 函数prototype属性
* 每个函数都有，默认指向的是一个Object空对象（原型对象）
* 原型对象中一个属性 construction 指向函数对象
* 作用：函数的所有实例对象，自动拥有原型中的属性

1. 显式原型
* 每个函数都有一个prototype属性，即显式原型（对象）
	* 声明函数时添加
	* 内部语句：this.prototype = {}
* 每个实例对象都有一个__proto__，即隐式原型（对象）
	* 创建实例对象添加（var fn = new Fn()）
	* 内部语句： this.__proto__ = Fn.prototype

* 对象隐式原型的值为其构造函数显式原型的值
* 程序员可以操作显式原型，但不能直接操作隐式原型（ES6之前）

##### 原型链
* 访问一个对象的属性时
	* 先在自身属性查找
	* 如果没有，沿着__proto__向上查找
	* 一直找到原型链的尽头，Object的原型对象的__proto__=null
	* 所以别名：隐式原型链


1. 函数显示原型指向的对象默认是空Object实例对象（Object不满足）
2. 所有函数都是Function的实例（包括Function）
3. Object的原型对象是原型链的尽头，Object.prototype.__proto__=null

##### 原型链_属性问题
* 读取对象属性值时，会自动查找原型链
* 给对象设置属性值，不会查找原型链，如果当前对象没有，这直接添加
* 方法一般定义在原型上，属性通过构造函数定义在对象本身

##### instanceof
* 表达式 ： A instanceof B
* 如果B函数的显式原型对象在A对象的原型链上，返回true
	* Object instanceof Object
	* Object instanceof Function
	* Function instanceof Function
	* Function instanceof Object

***
![avatar](pic/原型链.jpg)
***


#### 执行上下文与执行上下文栈
##### 变量提升与函数提升
* 变量提升
	* 通过var定义的变量，在定义语句之前就可以访问到，值：undefined
```
	console.log(a)
	var a = 3
```
自动变成
```
	var a
	console.log(a) //输出undefined
	a = 3
```
* 函数提升
	* 通过function声明的函数，在之前就可以直接调用
	* function fn1（）{} 提升
	* var fn2 = function(){} 不提升，fn2先被看作变量

*先变量提升，再函数提升*

##### 执行上下文
1. 全局执行上下文
	* 执行全局代码前将window确定为全局执行上下文
	* 对全局数据进行预处理
		* var定义的全局变量 ==undefined 添加到window的属性
		* function声明的全局函数 ==赋值，添加为window的方法
		* this==>赋值window

2. 函数执行上下文
	* 在调用函数，准备执行函数体之前，创建一个函数执行上下文对象
	* 对局部数据预处理
		* 形参变量==> 赋值实参==> 添加为执行上下文属性
		* arguments==> 赋值是参列表，添加为上下文属性
		* var定义局部变量 ==undefined 添加为上下文属性
		* function声明局部变量 ==赋值，添加为为上下文方法
		* this ==> 赋值调用函数的对象
	* 开始执行函数

##### 执行上下文栈
1. 在全局代码执行前，JS引擎就会创建一个栈来存储管理所有执行上下文对象
2. 在全局执行上下文window确定后，window压如栈
3. 在函数执行上下文创建后，压入栈
4. 执行完，出栈
5. 程序执行完，window出栈
   

#### 作用域和作用域链
##### 作用域
* 没有块作用域（ES6前）
* 不同作用域中同名变量不冲突
* 作用域数量n+1
* 作用域在函数定义时就确定了

##### 作用域链

#### 闭包
##### 给三个按钮点击显示第几个
```
		<!-- 正确的 -->
        for(i = 0;i<btn.length;i++){
            btn[i].index = i
            btn[i].onclick = function(){
                alert(this.index)
            }
        }
```

```
			<!-- 错误的 -->
	        for(i=0;i<btn.length;i++){
            btn[i].onclick = function(){
                alert(i);
            }
        }
```

##### 闭包定义
1. 如何产生闭包？
* 当一个嵌套的内部子函数引用了嵌套外部父函数的变量（函数）时，就产生闭包

2. 如何理解闭包？
* 理解一：闭包是嵌套的内部函数(绝大部分人)
* 理解二：包含被引用变量（函数）的对象（少数人）

3. 产生闭包的条件
* 函数嵌套
* 内部函数引用外部函数的数据（变量、函数）

4. 什么时候产生
* 执行函数定义就会产生闭包（不用调用外部函数）

##### 常见的闭包
1. 将一个函数作为另一个函数的返回值  

2. 将函数作为实参传递给另一个函数调用

##### 闭包的作用
1. 使用函数内部的变量在函数执行完成后，仍然活在内存中（延长了局部变量的生命周期）
2. 使函数外部可以操作（读写）到函数内部的数据（变量/函数）

##### 闭包的生命周期
* 产生：嵌套内部函数顶一字型完时就产生了
* 死亡：在嵌套的内部函数成为垃圾对象时

##### 闭包的应用2
* 定义JS模块
1. return 封装成对象 向外暴露
2. 匿名函数自调用 window.属性名向外暴露

##### 闭包的缺点及解决
1. 缺点
	* 函数执行完后，函数内部局部变量没有释放，占用内存时间会变长
	* 容易造成内存泄露
2. 解决
	* 让内部函数成为垃圾对象，从而回收闭包对象

>	内存溢出：程序运行需要内存超过剩余内存
>	内存泄漏：占用的内存没有及时释放，积累多了容易导致内存溢出
>> 1. 意外的全局变量
>> 2. 启动定时器后不清理
>> 3. 闭包

##### 闭包定义
1. 如何产生闭包？
* 当一个嵌套的内部子函数引用了嵌套外部父函数的变量（函数）时，就产生闭包

2. 如何理解闭包？
* 理解一：闭包是嵌套的内部函数(绝大部分人)
* 理解二：包含被引用变量（函数）的对象（少数人）

3. 产生闭包的条件
* 函数嵌套
* 内部函数引用外部函数的数据（变量、函数）

4. 什么时候产生
* 执行函数定义就会产生闭包（不用调用外部函数）

##### 常见的闭包
1. 将一个函数作为另一个函数的返回值  

2. 将函数作为实参传递给另一个函数调用

##### 闭包的作用
1. 使用函数内部的变量在函数执行完成后，仍然活在内存中（延长了局部变量的生命周期）
2. 使函数外部可以操作（读写）到函数内部的数据（变量/函数）

##### 闭包的生命周期
* 产生：嵌套内部函数顶一字型完时就产生了
* 死亡：在嵌套的内部函数成为垃圾对象时

##### 闭包的应用2
* 定义JS模块
1. return 封装成对象 向外暴露
2. 匿名函数自调用 window.属性名向外暴露

##### 闭包的缺点及解决
1. 缺点
	* 函数执行完后，函数内部局部变量没有释放，占用内存时间会变长
	* 容易造成内存泄露
2. 解决
	* 让内部函数成为垃圾对象，从而回收闭包对象

>	内存溢出：程序运行需要内存超过剩余内存
>	内存泄漏：占用的内存没有及时释放，积累多了容易导致内存溢出
>> 1. 意外的全局变量
>> 2. 启动定时器后不清理
>> 3. 闭包

***

### 面向对象高级
#### 对象创建模式
1.	Object构造函数方式
 	```
 	var obj = new Object()
 	obj.name = "zj"
 	...
 	```
2. 使用字面量创建对象
	```
	var obj = {
		name:'zj',
		...
	}
	```

3. 工厂模式
```
	function createObj(name,age){
		var obj = {
			name:name,
			age:age,
			setName:function(name){
				this.name = name
			}
		}
		return obj
	}
```

4. 自定义构造函数模式
```
	function Person(name,age){
		this.name = name
		this.age = age
	}

	var p1 = new Person("zj",20)
```

* 公共的属性和方法，放到Person的原型对象里

#### 继承模式
##### 原型链继承
* 子类型的原型为父类型的一个实例对象
```
	Son.prototype = new Father()
```

* 让子类型的原型的constructor指向子类型
```
	Sub.prototype.constructor = Sub
```

##### 借用构造函数继承（假）
> 通过call函数调用父类型的构造方法

##### 组合两种 组合继承

****
### 线程，进程
#### 进程（process） 线程（thread）
#### 浏览器内核
* 多模块组成
	* js引擎模块：负责js程序的编译与运行
	* html，css文档的解析模块
	* Dom/CSS模块：负责dom/css在内存中的相关处理
	* 布局与渲染模块

#### 定时器
* 不是精准的，会延迟一点，也有可能延迟很长一段时间

#### JS是单线程的
* alert会暂停当前主进程的执行，同时暂停计时，点击确定后恢复
* 初始化代码执行完之后才会执行回调代码

> 模型：
>> 事件（定时器、DOM、ajax）管理模块
>> 回调队列




























